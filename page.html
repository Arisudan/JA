<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Drive Cycle - Pi Rider Display</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { background:#061018; color:#dfe9f3; font-family: "Segoe UI", Arial, sans-serif; margin:0; padding:10px; }
    #top { display:flex; gap:12px; align-items:center; }
    .card { background:#0d1820; padding:10px; border-radius:8px; box-shadow:0 3px 10px rgba(0,0,0,0.6); }
    #speed { font-size:64px; color:#7fffd4; font-weight:800; width:200px; text-align:center; }
    .small { font-size:12px; color:#9fb0c9; }
    .label { font-size:12px; color:#9fb0c9; margin-bottom:4px; }
    #controls { display:flex; gap:10px; align-items:center; }
    .btn { padding:8px 12px; border-radius:6px; border:0; font-weight:700; cursor:pointer; }
    .btn.start { background:#8ef27c; color:#000; }
    .btn.stop { background:#ff6b6b; color:#fff; }
    #canvas-wrap { margin-top:14px; background:#06111a; padding:8px; border-radius:8px; height:480px; border:3px solid #032b3f; }
    #chart { width:100%; height:100%; display:block; }
    #right-controls { margin-left:auto; display:flex; gap:12px; align-items:center; }
    input[type=range] { width:260px; }
    .status { padding:6px 10px; border-radius:6px; background:#071a20; color:#cfe8ff; }
    .danger { background:#381111; color:#ffb3b3; }
    .ok { background:#113814; color:#baffc9; }
  </style>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
</head>
<body>
  <div id="top" style="align-items:flex-start;">
    <div class="card" style="display:flex;gap:18px;align-items:center;">
      <div style="text-align:center;">
        <div class="small">ACTUAL</div>
        <div id="speed">0.0</div>
        <div class="small">km/h</div>
      </div>
      <div style="text-align:center;">
        <div class="small">TARGET</div>
        <div id="target">0.0</div>
        <div class="small">km/h</div>
      </div>
      <div style="text-align:center;">
        <div class="small">ELAPSED</div>
        <div id="time">0.00</div>
        <div class="small">s</div>
      </div>
      <div style="text-align:center;">
        <div class="small">VIOLATIONS</div>
        <div id="viol">0</div>
      </div>
    </div>

    <div class="card" id="controls" style="min-width:560px;">
      <button id="startBtn" class="btn start">Start</button>
      <button id="stopBtn" class="btn stop">Stop</button>
      <button id="resetBtn" class="btn">Reset</button>

      <div style="margin-left:8px;">
        <div class="label">MODE</div>
        <select id="mode">
          <option value="manual">Manual (Slider)</option>
          <option value="real">Real Sensor</option>
        </select>
      </div>

      <div style="margin-left:8px;">
        <div class="label">MANUAL SPEED</div>
        <input id="slider" type="range" min="0" max="140" step="0.1" value="0">
        <div id="sliderVal" class="small">0.0 km/h</div>
      </div>

      <div id="right-controls">
        <div>
          <div class="label">WINDOW (s)</div>
          <input id="windowIn" type="number" min="5" max="300" value="20" style="width:70px">
        </div>
        <div>
          <div class="label">LEAD %</div>
          <input id="leadIn" type="number" min="0" max="80" value="30" style="width:70px">
        </div>
        <div>
          <div class="label">Min Viol (s)</div>
          <input id="minViol" type="number" min="0.1" max="10" step="0.1" value="1.0" style="width:70px">
        </div>
      </div>
    </div>
  </div>

  <div id="canvas-wrap" class="card">
    <canvas id="chart"></canvas>
  </div>

  <div style="margin-top:8px; display:flex; gap:10px; align-items:center;">
    <div id="violationPending" class="status" style="display:none;">Violation pending: <span id="pendingTime">0.0</span>s</div>
    <div id="connectionStatus" class="status">WS: <span id="wsState">â€”</span></div>
  </div>

<script>
const WS_URL = "ws://localhost:8765";
let ws = null;
let profile = { time:[], target:[], upper:[], lower:[] };
let chart = null;
let windowSeconds = 20;        // horizontal visible seconds
let leadFraction = 0.30;      // marker position from left (0..1)
let minViolationClient = 1.0; // seconds used for pending indicator (user controlled)
let lastViolations = 0;
let pendingStart = null;      // when frontend detected out_of_range started
let lastUpdate = null;

function connectWS() {
  ws = new WebSocket(WS_URL);
  ws.onopen = () => {
    console.log("WS open");
    document.getElementById('wsState').innerText = "open";
  };
  ws.onmessage = (ev) => {
    try {
      const obj = JSON.parse(ev.data);
      handleMessage(obj);
    } catch (e) {
      console.warn("Bad ws msg", e);
    }
  };
  ws.onclose = () => {
    console.log("WS closed");
    document.getElementById('wsState').innerText = "closed";
    setTimeout(connectWS, 1000);
  };
  ws.onerror = (e) => {
    console.log("WS error", e);
    document.getElementById('wsState').innerText = "error";
  };
}

function sendCmd(obj) {
  if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(obj));
}

function handleMessage(obj) {
  if (obj.type === "profile") {
    profile = obj.profile;
    drawProfile();
    // adjust window if profile end is large
    const maxT = profile.time && profile.time.length ? profile.time[profile.time.length-1] : 0;
    if (maxT > 120 && windowSeconds < 30) {
      windowSeconds = Math.min(60, Math.round(maxT / 6));
      document.getElementById('windowIn').value = windowSeconds;
    }
  } else if (obj.type === "update") {
    // update numeric UI
    document.getElementById('speed').innerText = (obj.actual ?? 0).toFixed(1);
    document.getElementById('target').innerText = (obj.target ?? 0).toFixed(1);
    document.getElementById('time').innerText = (obj.time ?? 0).toFixed(2);
    document.getElementById('viol').innerText = (obj.violations ?? 0);

    // detect pending/counting based on client-side minViol value
    handlePending(obj);

    // update chart
    addActualPoint(obj.time, obj.actual, obj.upper, obj.lower);
    lastUpdate = obj;
  } else if (obj.type === "reset") {
    if (chart) {
      chart.data.datasets[3].data = [];
      chart.update();
    }
    lastViolations = 0;
    pendingStart = null;
    hidePending();
  } else if (obj.type === "complete") {
    alert("Test complete! Violations: " + obj.violations);
  }
}

// draw profile
function drawProfile() {
  const times = profile.time || [];
  const targetData = (profile.target || []).map((v,i) => ({x: times[i], y: v}));
  const upperData = (profile.upper || []).map((v,i) => ({x: times[i], y: v}));
  const lowerData = (profile.lower || []).map((v,i) => ({x: times[i], y: v}));

  const ctx = document.getElementById('chart').getContext('2d');
  if (chart) chart.destroy();

  chart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [
        { label: 'Upper', data: upperData, borderColor:'#ff3b3b', borderWidth:2, pointRadius:0, fill:false, tension:0 },
        { label: 'Lower', data: lowerData, borderColor:'#1e90ff', borderWidth:2, pointRadius:0, fill:'-1', tension:0 },
        { label: 'Target', data: targetData, borderColor:'#2ee36b', borderWidth:2.5, pointRadius:0, fill:false, tension:0.2 },
        { label: 'Actual', data: [], borderColor:'#ffd400', borderWidth:3, pointRadius:4, backgroundColor:'#ffd400', fill:false, tension:0.4 }
      ]
    },
    options: {
      animation:false,
      responsive:true,
      maintainAspectRatio:false,
      elements: { line: { cubicInterpolationMode: 'monotone' } },
      scales: {
        x: {
          type: 'linear',
          title:{display:true, text:'Time (s)', color:'#cfe8ff'},
          ticks: { stepSize: 1, color:'#cfe8ff' },
          min: times.length? Math.max(0, times[0]) : 0,
          max: times.length? Math.max(windowSeconds, times[Math.min(times.length-1, Math.floor(windowSeconds))]) : windowSeconds
        },
        y: {
          title:{display:true, text:'Speed (km/h)', color:'#cfe8ff'},
          min:0,
          max: 120,
          ticks: { color:'#cfe8ff' }
        }
      },
      plugins: {
        legend: { display: true, labels: { color:'#dfe9f3' } }
      }
    }
  });
}

// add actual point and slide window with lead
function addActualPoint(t, speed, upper, lower) {
  if (!chart || t === null || t === undefined) return;
  const ds = chart.data.datasets[3];
  ds.data.push({x: t, y: speed});

  // prune old points
  const minKeep = t - (windowSeconds + 10);
  chart.data.datasets.forEach(d => {
    d.data = d.data.filter(pt => pt.x >= minKeep);
  });

  // compute visible min/max using leadFraction
  let visible_min = t - (windowSeconds * leadFraction);
  if (visible_min < 0) visible_min = 0;
  let visible_max = visible_min + windowSeconds;

  // clamp to profile end (allow slight preview beyond end)
  if (profile.time && profile.time.length) {
    const prof_end = profile.time[profile.time.length - 1];
    if (visible_max > prof_end + 1) {
      visible_max = Math.min(visible_max, prof_end + 1);
      visible_min = Math.max(0, visible_max - windowSeconds);
    }
  }

  chart.options.scales.x.min = visible_min;
  chart.options.scales.x.max = visible_max;
  chart.update('none');
}

// pending detection + UI
function handlePending(obj) {
  const t = obj.time || 0;
  const actual = parseFloat(obj.actual || 0);
  const upper = parseFloat(obj.upper || 1e9);
  const lower = parseFloat(obj.lower || -1e9);
  const viols = parseInt(obj.violations || 0);

  // update minViolation from user input
  const mv = parseFloat(document.getElementById('minViol').value) || 1.0;
  minViolationClient = mv;

  // if server already incremented violations, clear pending
  if (viols > lastViolations) {
    lastViolations = viols;
    pendingStart = null;
    hidePending();
    return;
  }

  const out_of_range = (actual < lower) || (actual > upper);

  if (t <= 0) { // not started yet
    pendingStart = null;
    hidePending();
    return;
  }

  if (out_of_range) {
    if (!pendingStart) {
      pendingStart = t;
    }
    const dur = Math.max(0, t - pendingStart);
    const remaining = Math.max(0, (minViolationClient - dur));
    showPending(dur, remaining);
  } else {
    pendingStart = null;
    hidePending();
  }
}

function showPending(dur, remaining) {
  const el = document.getElementById('violationPending');
  el.style.display = 'inline-block';
  el.className = remaining <= 0 ? 'status danger' : 'status';
  document.getElementById('pendingTime').innerText = dur.toFixed(2);
}

function hidePending() {
  const el = document.getElementById('violationPending');
  el.style.display = 'none';
}

// UI wiring
document.getElementById('startBtn').onclick = () => sendCmd({cmd:'start'});
document.getElementById('stopBtn').onclick = () => sendCmd({cmd:'stop'});
document.getElementById('resetBtn').onclick = () => { sendCmd({cmd:'reset'}); if (chart) { chart.data.datasets[3].data=[]; chart.update(); } };
document.getElementById('mode').onchange = (e) => sendCmd({cmd:'set_mode', mode: e.target.value});

const slider = document.getElementById('slider'), sliderVal = document.getElementById('sliderVal');
slider.oninput = (e) => {
  const v = parseFloat(e.target.value);
  sliderVal.innerText = v.toFixed(1) + " km/h";
  sendCmd({cmd:'manual_speed', speed: v});
};

const windowInput = document.getElementById('windowIn');
windowInput.onchange = (e) => {
  let v = parseFloat(e.target.value) || 20;
  v = Math.max(5, Math.min(300, v));
  windowSeconds = v;
  // adjust chart extents if we have latest time
  if (chart) {
    let latest = 0;
    const ds = chart.data.datasets[3].data;
    if (ds.length) latest = ds[ds.length-1].x;
    else if (profile.time && profile.time.length) latest = profile.time[profile.time.length-1];
    const visible_min = Math.max(0, latest - (windowSeconds * leadFraction));
    chart.options.scales.x.min = visible_min;
    chart.options.scales.x.max = visible_min + windowSeconds;
    chart.update();
  }
};

const leadInput = document.getElementById('leadIn');
leadInput.onchange = (e) => {
  let p = parseFloat(e.target.value) || 30;
  p = Math.max(0, Math.min(80, p));
  leadFraction = p / 100.0;
};

const minViolInput = document.getElementById('minViol');
minViolInput.onchange = (e) => {
  // purely client-side pending indicator; server uses its own configured min_violation
  minViolationClient = parseFloat(e.target.value) || 1.0;
};

// start WS
connectWS();
</script>
</body>
</html>
